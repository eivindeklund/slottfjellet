<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>{{ title }}</title>
  <link rel="stylesheet" href="style2.css" />
  <link
    rel="icon"
    type="image/png"
    href="/favicon/favicon-96x96.png"
    sizes="96x96"
  />
  <link rel="icon" type="image/svg+xml" href="/favicon/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link
    rel="apple-touch-icon"
    sizes="180x180"
    href="/favicon/apple-touch-icon.png"
  />
  <meta
    name="apple-mobile-web-app-title"
    content="Slottsfjellet Spillforening"
  />
  <link rel="manifest" href="/site.webmanifest" />
  <style>
    /** FADE TRANSTIONS DO NOT WORK.  There is a lot of code to try to make them
     * work correctly, but currently the do nothing.  It is not worth my time to
     * fix that, at least not right now. --Eivind */

    /* Base fade transition for time-controlled elements */
    /* Prevent initial flash: keep time-controlled elements hidden until
       JS runs and sets the correct visibility. This avoids a visible
       show-then-fade on first paint. */
    html:not(.time-controlled-ready) [data-show-after],
    html:not(.time-controlled-ready) [data-hide-after] {
      opacity: 0;
      pointer-events: none;
      transition: none !important;
    }
    /* Suppress transitions during the brief moment we flip the document to
       ready so the initial visibility changes happen instantly. */
    html.time-controlled-suppress-transitions [data-show-after],
    html.time-controlled-suppress-transitions [data-hide-after] {
      transition: none !important;
    }

    /* When the document is marked ready, enable the normal visible state
       and transitions for time-controlled elements. The selector targets
       elements under the html element that has the ready class. */
    html.time-controlled-ready [data-show-after],
    html.time-controlled-ready [data-hide-after],
    [data-show-after],
    [data-hide-after] {
      opacity: 1;
      transition: opacity 0.6s ease;
    }
    [data-show-after],
    [data-hide-after] {
      opacity: 1;
      transition: opacity 0.6s ease;
    }
    [data-hidden="true"] {
      opacity: 0;
      pointer-events: none;
    }
  </style>

  <script>
    (function () {
      // Parse time strings in a specific timezone (fallback: UTC)
      function parseInZone(timeString, zone) {
        // Robustly parse an ISO-like local date/time (without an explicit
        // timezone) into an absolute epoch (ms since UTC) corresponding to
        // that wall time in the given IANA timezone.
        // If the string already contains a timezone (Z or +/-), fall back to
        // Date.parse which understands offsets.
        try {
          if (/Z|[+-]\d{2}:?\d{2}$/.test(timeString)) {
            return Date.parse(timeString);
          }

          // Parse numeric components from e.g. 2025-10-31T14:51 or
          // 2025-10-31 14:51:30
          const m = timeString.match(
            /^(\d{4})-(\d{2})-(\d{2})(?:[T\s](\d{2}):(\d{2})(?::(\d{2}))?)?$/
          );
          if (!m) return Date.parse(timeString);

          const year = Number(m[1]);
          const month = Number(m[2]);
          const day = Number(m[3]);
          const hour = Number(m[4] || 0);
          const minute = Number(m[5] || 0);
          const second = Number(m[6] || 0);

          // Construct a UTC epoch that has the same numeric fields as the
          // wall time (i.e. interpret the fields as if they were UTC).
          const asIfUtc = Date.UTC(year, month - 1, day, hour, minute, second);

          // Ask Intl what the timezone would format that UTC instant to.
          const dtf = new Intl.DateTimeFormat("en-US", {
            timeZone: zone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: false,
          });
          const parts = dtf.formatToParts(new Date(asIfUtc));
          const map = Object.fromEntries(parts.map((p) => [p.type, p.value]));

          // Build an epoch from the zone-formatted components as if those
          // components were UTC. The difference between that epoch and the
          // asIfUtc epoch equals the timezone offset at that instant.
          const zoneMillis = Date.UTC(
            Number(map.year),
            Number(map.month) - 1,
            Number(map.day),
            Number(map.hour),
            Number(map.minute),
            Number(map.second)
          );

          const offset = zoneMillis - asIfUtc;
          // The real epoch for the given wall time in `zone` is adjusted by
          // subtracting that offset.
          return asIfUtc - offset;
        } catch (err) {
          // Fallback to browser parsing for anything we can't handle.
          alert(
            "Error parsing time string, falling back to Date.parse but that is not OK. Error: " +
              err.message
          );
          return Date.parse(timeString);
        }
      }

      // Track whether this is the first run. On the first run we set visibility
      // instantly (no fade) to avoid a flash or visible fade-out on page load.
      let initialRun = true;

      function updateTimeVisibility() {
        const now = Date.now();

        document
          .querySelectorAll("[data-show-after], [data-hide-after]")
          .forEach((el) => {
            const zone = el.dataset.timezone || "UTC";
            const showAfter = el.dataset.showAfter
              ? parseInZone(el.dataset.showAfter, zone)
              : -Infinity;
            const hideAfter = el.dataset.hideAfter
              ? parseInZone(el.dataset.hideAfter, zone)
              : Infinity;
            const shouldShow = now >= showAfter && now < hideAfter;
            const isHidden = el.dataset.hidden === "true";

            if (shouldShow && isHidden) {
              // Fade in (or show instantly during initial run)
              el.style.display = "";
              if (initialRun) {
                el.dataset.hidden = "false";
              } else {
                requestAnimationFrame(() => {
                  el.dataset.hidden = "false";
                });
              }
            } else if (!shouldShow && !isHidden) {
              // Hide. On initial run remove immediately to avoid a noticeable
              // fade-out during page load; afterwards keep the fade and delay
              // layout removal to match the transition.
              el.dataset.hidden = "true";
              if (initialRun) {
                el.style.display = "none";
              } else {
                setTimeout(() => {
                  if (el.dataset.hidden === "true") el.style.display = "none";
                }, 600); // match transition
              }
            }
          });

        // After the first run, mark ready so subsequent changes animate.
        if (initialRun) {
          initialRun = false;
          // Add ready + suppress-transitions on the next frame, then remove the
          // suppress flag on the following frame. This double-rAF ensures the
          // initial show/hide changes we just applied take effect instantly
          // (no transition), while subsequent visibility changes will
          // transition normally.
          requestAnimationFrame(() => {
            document.documentElement.classList.add(
              "time-controlled-ready",
              "time-controlled-suppress-transitions"
            );
            requestAnimationFrame(() => {
              document.documentElement.classList.remove(
                "time-controlled-suppress-transitions"
              );
            });
          });
        }
      }

      // Run the first visibility calculation after the DOM is parsed so we can
      // immediately set the correct visibility before the page is painted.
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
          updateTimeVisibility();
          setInterval(updateTimeVisibility, 1000);
        });
      } else {
        updateTimeVisibility();
        setInterval(updateTimeVisibility, 1000);
      }
    })();
  </script>
</head>
