<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>{{ title }}</title>
  <link rel="stylesheet" href="style2.css" />
  <link
    rel="icon"
    type="image/png"
    href="/favicon/favicon-96x96.png"
    sizes="96x96"
  />
  <link rel="icon" type="image/svg+xml" href="/favicon/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link
    rel="apple-touch-icon"
    sizes="180x180"
    href="/favicon/apple-touch-icon.png"
  />
  <meta
    name="apple-mobile-web-app-title"
    content="Slottsfjellet Spillforening"
  />
  <link rel="manifest" href="/site.webmanifest" />
  <style>
    /* Base fade transition for time-controlled elements */
    /* Prevent initial flash: keep time-controlled elements hidden until
       JS runs and sets the correct visibility. This avoids a visible
       show-then-fade on first paint. */
    html:not(.time-controlled-ready) [data-show-after],
    html:not(.time-controlled-ready) [data-hide-after] {
      opacity: 0;
      pointer-events: none;
      transition: none !important;
    }
    .time-controlled-ready[data-show-after],
    .time-controlled-ready[data-hide-after] {
      opacity: 1;
      transition: opacity 0.6s ease;
    }
    [data-hidden="true"] {
      opacity: 0;
      pointer-events: none;
    }
  </style>

  <script>
    (function () {
      // Parse time strings in a specific timezone (fallback: UTC)
      function parseInZone(timeString, zone) {
        try {
          const dtf = new Intl.DateTimeFormat("en-US", {
            timeZone: zone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: false,
          });
          const parts = dtf.formatToParts(new Date(timeString));
          const map = Object.fromEntries(parts.map((p) => [p.type, p.value]));
          return Date.parse(
            `${map.year}-${map.month}-${map.day}T${map.hour}:${map.minute}:${map.second}Z`
          );
        } catch {
          return Date.parse(timeString); // fallback to normal parse
        }
      }

      // Track whether this is the first run. On the first run we set visibility
      // instantly (no fade) to avoid a flash or visible fade-out on page load.
      let initialRun = true;

      function updateTimeVisibility() {
        const now = Date.now();

        document
          .querySelectorAll("[data-show-after], [data-hide-after]")
          .forEach((el) => {
            const zone = el.dataset.timezone || "UTC";
            const showAfter = el.dataset.showAfter
              ? parseInZone(el.dataset.showAfter, zone)
              : -Infinity;
            const hideAfter = el.dataset.hideAfter
              ? parseInZone(el.dataset.hideAfter, zone)
              : Infinity;
            const shouldShow = now >= showAfter && now < hideAfter;
            const isHidden = el.dataset.hidden === "true";

            if (shouldShow && isHidden) {
              // Fade in (or show instantly during initial run)
              el.style.display = "";
              if (initialRun) {
                el.dataset.hidden = "false";
              } else {
                requestAnimationFrame(() => {
                  el.dataset.hidden = "false";
                });
              }
            } else if (!shouldShow && !isHidden) {
              // Hide. On initial run remove immediately to avoid a noticeable
              // fade-out during page load; afterwards keep the fade and delay
              // layout removal to match the transition.
              el.dataset.hidden = "true";
              if (initialRun) {
                el.style.display = "none";
              } else {
                setTimeout(() => {
                  if (el.dataset.hidden === "true") el.style.display = "none";
                }, 600); // match transition
              }
            }
          });

        // After the first run, mark ready so subsequent changes animate.
        if (initialRun) {
          initialRun = false;
          // Add a class to the document element on the next animation frame so
          // the browser doesn't paint the page with the pre-JS styles and
          // trigger an unwanted visible fade. requestAnimationFrame runs
          // before the next paint, which prevents the flash.
          requestAnimationFrame(() => {
            document.documentElement.classList.add("time-controlled-ready");
          });
        }
      }

      // Run the first visibility calculation after the DOM is parsed so we can
      // immediately set the correct visibility before the page is painted.
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
          updateTimeVisibility();
          setInterval(updateTimeVisibility, 1000);
        });
      } else {
        updateTimeVisibility();
        setInterval(updateTimeVisibility, 1000);
      }
    })();
  </script>
</head>
