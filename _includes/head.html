<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>{{ title }}</title>
  <link rel="stylesheet" href="style2.css" />
  <link
    rel="icon"
    type="image/png"
    href="/favicon/favicon-96x96.png"
    sizes="96x96"
  />
  <link rel="icon" type="image/svg+xml" href="/favicon/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link
    rel="apple-touch-icon"
    sizes="180x180"
    href="/favicon/apple-touch-icon.png"
  />
  <meta
    name="apple-mobile-web-app-title"
    content="Slottsfjellet Spillforening"
  />
  <link rel="manifest" href="/site.webmanifest" />
  <style>
    /* Base fade transition for time-controlled elements */
    [data-show-after],
    [data-hide-after] {
      opacity: 1;
      transition: opacity 0.6s ease;
    }
    [data-hidden="true"] {
      opacity: 0;
      pointer-events: none;
    }
  </style>

  <script>
    (function () {
      // Parse time strings in a specific timezone (fallback: UTC)
      function parseInZone(timeString, zone) {
        try {
          const dtf = new Intl.DateTimeFormat("en-US", {
            timeZone: zone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: false,
          });
          const parts = dtf.formatToParts(new Date(timeString));
          const map = Object.fromEntries(parts.map((p) => [p.type, p.value]));
          return Date.parse(
            `${map.year}-${map.month}-${map.day}T${map.hour}:${map.minute}:${map.second}Z`
          );
        } catch {
          return Date.parse(timeString); // fallback to normal parse
        }
      }

      function updateTimeVisibility() {
        const now = Date.now();

        document
          .querySelectorAll("[data-show-after], [data-hide-after]")
          .forEach((el) => {
            const zone = el.dataset.timezone || "UTC";
            const showAfter = el.dataset.showAfter
              ? parseInZone(el.dataset.showAfter, zone)
              : -Infinity;
            const hideAfter = el.dataset.hideAfter
              ? parseInZone(el.dataset.hideAfter, zone)
              : Infinity;
            const shouldShow = now >= showAfter && now < hideAfter;
            const isHidden = el.dataset.hidden === "true";

            if (shouldShow && isHidden) {
              // Fade in
              el.style.display = "";
              requestAnimationFrame(() => {
                el.dataset.hidden = "false";
              });
            } else if (!shouldShow && !isHidden) {
              // Fade out but delay layout removal
              el.dataset.hidden = "true";
              setTimeout(() => {
                if (el.dataset.hidden === "true") el.style.display = "none";
              }, 600); // match transition
            }
          });
      }

      updateTimeVisibility();
      setInterval(updateTimeVisibility, 1000);
    })();
  </script>
</head>
